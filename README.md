# itmo_planning
## Отчёт

**Overleaf** с некоторых пор запретил совместное редактирование бесплатным аккаунтом, поэтому мы переходим на новый редактор
\[актуальная ссылка готовится\]
[Papeeria](https://www.papeeria.com/join?token_id=bb04ee57-733d-49ec-9e37-7c463f110cd8&retry=3)

Так же, для хранения отчёта создан отдельный репозиторий, который синхронизирован с **Papeeria**. Он добавлен в сабмодули текущего репоза.


Для того, что бы подгрузить репозиторий с отчётом выполните следующие команды:
```
git submodule init
git submodule update
```



## Готовим среду
Если не хотим качать менеджер сред, то руками устанавливаем python (проверено на 3.12.8) и все нужные пакеты:

`pip install mujoco>=3.2.6 numpy matplotlib`. Можно добавить `roboticstoolbox-python` (вроде по заданию надо его юзать, мб в регуляторе), но для текущего кода это не требуется.

Если хотим проще, то качаем менеджер виртуальных сред по ссылке https://docs.conda.io/projects/conda/en/latest/user-guide/install/windows.html
(установка тривиальная, обычный exe, папку установки можно выбрать любую)

Anaconda - полная версия с кучей пакетов по дефолту, miniconda - урезанная с минимумом пакетов, miniforge - урезанная + есть продвинутый менеджер mamba, который работает быстрее, чем в предыдущих.
- В Anaconda/miniconda/miniforge:

`conda env create -f env.yml`
, затем активировать ее в IDE.
- В miniforge с продвинутым менеджером:

`mamba env create -f env.yml`
, затем активировать ее в IDE.

## Использование
В файле `example.py` есть пример запуска симуляции. 

Если при запуске `example.py` появляется окно MuJoCo -- все работает.

Можно нажать `Tab` и потыкать настройки, скрыть geom group 1 (это коллайдеры колес), чтобы остались красивые меши колес. 

В правой панели можно подвигать ползунки, задавая моменты на колесах.

`example_control.py` - скрипт для запуска симуляции с управлением по заданной траектории. Функция для формирования управления и траектории указывается в начале скрипта. Прототипы этих функций можно подсмотреть в `control.py` и `traj.py` соответственно

## Краткий экскурс
Удобная и подробная документация по MuJoCo: 
1. Про все элементы при построении модели в XML https://mujoco.readthedocs.io/en/stable/XMLreference.html
2. Небольшое интро про то, как пользоваться в питоне https://mujoco.readthedocs.io/en/stable/python.html

Функция `generate_scene()` создает описание будущей имитационной модели -- сцена по мотивам office2 и робот с 4-мя шведскими колесами.

Вспомогательный класс `SimHandler` готовит данные сцены из xml и запускает симуляцию в интерактивном окне методом `simulate()`. 

Вся модель генерируется процедурно, заранее готовы только меши для препятствий и колес. Если нужно задать или поменять параметры вроде масс, инерции, демпфирования, размеров - обращаемся к документации mujoco и редактируем нужные поля/переменные в файле `mecanum_gen.py`.

## FAQ
Чтобы выводить данные из симуляции, передаем в `SimHandler` параметр `simout`, реализующий `SimOutput`. У него будет вызван метод `prepare()`, который даст ему доступ к данным во время симуляции - скорости, координаты, усилия и тп в объекте `mjData` (см. документацию mujoco) и другим данным. Также будет вызван метод `update()`, который принимает номер текущего шага симуляции, чтобы связать снятые данные со временем. 

В примере я редактирую описание сцены, добавляя датчик скорости в заранее заготовленный site (объект-пустышка). SensorOutput будет записывать все указанные по именам датчики, потом можно построить графики от времени. Для других датчиков -- см. документацию mujoco, раздел sensor по первой ссылке.

Чтобы задавать свое управление, в метод `simulate()` передаем функцию control_func и кортеж доп. аргументов `conrol_func_args` (при необходимости). `control_func` будет вызываться на каждом шаге, зная текущее время и состояние `mjData`, и должна возвращать значения управления для всех актуаторов в сцене (в нашем случае 4 идеальных актуатора (выдают усилие равное входу), нумерация -- как в реферате). 

`control_func` знает о текущем состоянии робота и датчиков. Обобщ. координаты, например, можно снимать из `data.qpos`, но там придется узнать индексы нужных джоинтов, проще создать датчики на нужных джоинтах по их именам. 


